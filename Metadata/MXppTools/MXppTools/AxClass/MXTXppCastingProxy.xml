<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>MXTXppCastingProxy</Name>
	<SourceCode>
		<Declaration><![CDATA[
using XppInterpreter.Interpreter.Proxy;
using Microsoft.Dynamics.Ax;


/// <summary>
/// Cast proxy used by the interpreter
/// </summary>
internal final class MXTXppCastingProxy implements XppInterpreter.Interpreter.Proxy.IXppCastingProxy
{
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>getXppTypeByTypeName</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieve the Types type by name
    /// </summary>
    /// <param name = "_name">Type name</param>
    /// <returns>Types type</returns>
    private Types getXppTypeByTypeName(str _name)
    {
        // Base Enums
        if (SysDictEnum::newName(_name) != null)
        {
            return Types::Enum;
        }

        // Extended data types
        var dictType = SysDictType::newName(_name);
        if (dictType != null)
        {
            return dictType.baseType();
        }

        //Common
        if (SysDictTable::newName(_name) != null)
        {
            return Types::Record;
        }

        // Classes
        if (SysDictClass::newName(_name) != null)
        {
            return Types::Class;
        }

        switch(_name)
        {
            case MXtXppTypes::RealTypeStr: return Types::Real;
            case MXtXppTypes::Int32TypeStr: return Types::Integer;
            case MXtXppTypes::GuidTypeStr: return Types::Guid;
            case MXtXppTypes::ContainerTypeStr: return Types::Container;
            case MXtXppTypes::Int64TypeStr: return Types::Int64;
            case MXtXppTypes::DateTimeTypeStr: return Types::UtcDateTime;
            case MXtXppTypes::StringTypeStr: return Types::String;
            case MXtXppTypes::DateTypeStr : return Types::Date;
            case MXtXppTypes::AnyTypeTypeStr: return Types::AnyType;
        }

        return Types::void;
    }

]]></Source>
			</Method>
			<Method>
				<Name>GetSystemTypeFromTypeName</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the System.Type by native type name (str, int, boolean...)
    /// </summary>
    /// <param name = "_typeName">Native type name</param>
    /// <returns></returns>
    public System.Type GetSystemTypeFromTypeName(str _typeName)
    {
        // boolean is not a type for some reason
        boolean isBoolean = _typeName == MXtXppTypes::BooleanTypeStr;

        if (isBoolean)
            return MXTXppTypes::BooleanType;

        var xppType = this.getXppTypeByTypeName(_typeName);

        switch (xppType)
        {
            case Types::Class:
                return Microsoft.Dynamics.Ax.Xpp.ReflectionCallHelper::GetTypeFromClassName(_typeName);

            case Types::Enum:
            case Types::Record:
                return Microsoft.Dynamics.Ax.Xpp.ReflectionCallHelper::getType(_typeName);

            case Types::Integer: 
                return MXTXppTypes::Int32Type;

            case Types::Int64: 
                return MXTXppTypes::Int64Type;

            case Types::Guid: 
                return MXTXppTypes::GuidType;

            case Types::Real:
                return MXTXppTypes::DecimalType;

            case Types::String:
                return MXTXppTypes::StringType;

            case Types::UtcDateTime:
                return MXTXppTypes::DateTimeType;

            case Types::Container:
                return MXTXppTypes::ContainerType;

            case Types::Date:
                return MXTXppTypes::DateType;

            case Types::AnyType:
                return MXTXppTypes::AnyTypeType;
        }

        return null;
    }

]]></Source>
			</Method>
			<Method>
				<Name>ToBoolean</Name>
				<Source><![CDATA[
    /// <summary>
    /// Casts an object into a boolean
    /// </summary>
    /// <param name = "value"></param>
    /// <returns></returns>
	public boolean ToBoolean(System.Object value)
    {
        return value;
	}

]]></Source>
			</Method>
			<Method>
				<Name>CreateDynamicArray</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a native dynamic array of the given type as string
    /// </summary>
    /// <param name = "typeName">Array type</param>
    /// <returns>Dynamics array as an object</returns>
    public System.Object CreateDynamicArray(System.String typeName)
    {
        System.Type type = this.GetSystemTypeFromTypeName(typeName);

        return XppInterpreter.Core.ReflectionHelper::MakeGenericInstance(MXTXppTypes::ArrayType, type);
    }

]]></Source>
			</Method>
			<Method>
				<Name>CreateFixedArray</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a native fixed sized array of the given type as string
    /// </summary>
    /// <param name = "typeName">Array type</param>
    /// <param name = "size">Array size</param>
    /// <returns>Fixed size array as an object</returns>
    public System.Object CreateFixedArray(System.String typeName, System.Int32 size)
    {
        System.Type type = this.GetSystemTypeFromTypeName(typeName);

        return XppInterpreter.Core.ReflectionHelper::MakeGenericInstance(MXTXppTypes::ArrayType, type, size);
    }

]]></Source>
			</Method>
			<Method>
				<Name>GetArrayIndexValue</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the value of an array by index performing type and boundary checks
    /// </summary>
    /// <param name = "array">Array object</param>
    /// <param name = "idx">Index</param>
    /// <returns>Value</returns>
    public System.Object GetArrayIndexValue(System.Object array, System.Int32 idx)
    {
        if (!array.GetType().IsGenericType || array.GetType().GetGenericTypeDefinition() != MXTXppTypes::ArrayType)
        {
            throw Error("The array indexing can only be applied to X++ array types.");
        }
        else
        {
            return XppInterpreter.Core.ReflectionHelper::GetEdtArrayIndexerValue(array, idx);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>SetArrayIndexValue</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the value of an array by index performing type and boundary checks
    /// </summary>
    /// <param name = "array">Array object</param>
    /// <param name = "idx">Index</param>
    /// <param name = "value">Value</param>
    public void SetArrayIndexValue(System.Object array, System.Int32 idx, System.Object value)
    {
        if (!array.GetType().IsGenericType || array.GetType().GetGenericTypeDefinition() != MXTXppTypes::ArrayType)
        {
            throw Error("The array indexing can only be applied to X++ array types.");
        }
        else
        {
            XppInterpreter.Core.ReflectionHelper::SetEdtArrayIndexerValue(array, idx, value);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>As</Name>
				<Source><![CDATA[
    /// <summary>
    /// Executes the as statement
    /// </summary>
    /// <param name = "_value">Value to cast</param>
    /// <param name = "_typeName">Type cast</param>
    /// <returns></returns>
    public System.Object As(System.Object _value, System.String _typeName)
    {
        if (this.Is(_value, _typeName))
        {
            return _value;
        }

        return null;
    }

]]></Source>
			</Method>
			<Method>
				<Name>Is</Name>
				<Source><![CDATA[
    /// <summary>
    /// Executes the is statement
    /// </summary>
    /// <param name = "_value">Value to check</param>
    /// <param name = "_typeName">Type name to check</param>
    /// <returns></returns>
    public System.Boolean Is(System.Object _value, System.String _typeName)
    {
        if (className2Id(_typeName))
        {
            ClassId         classId,
                            newClassId = className2Id(_typeName);
            SysDictClass    sysDictClass;
            boolean         ret;
            
            classId = classIdGet(_value);
            if (classId == 0)
            {
                return false;
            }

            sysDictClass = new SysDictClass(classId);

            ret = sysDictClass.isImplementing(newClassId);

            if (!ret)
            {
                ret = SysDictClass::isEqualOrSuperclass(classId, newClassId);
            }

            return ret;
        }
        else if (tableName2Id(_typeName))
        {
            // Validate if it's common'
            if (_value)
            {
                System.Type valueType = _value.GetType();
                boolean isCommonType = valueType == MXTXppTypes::CommonType || valueType.IsSubclassOf(MXTXppTypes::CommonType);

                if (!isCommonType)
                {
                    return false;
                }
                else if (_typeName == 'Common')
                {
                    return true;
                }
            }

            // Validate extends
            TableId  sourceTableId = tableName2Id(_value.GetType().Name);
            TableId  targetTableId = tablename2id(_typeName);
            
            if (sourceTableId == targetTableId)
            {
                return true;
            }

            while (sourceTableId)
            {
                DictTable dt = new DictTable(sourceTableId);

                if (dt.extends() != targetTableId)
                {
                    sourceTableId = dt.extends();
                }
                else
                {
                    return true;
                }
            }
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>GetDefaultValueForType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the default value for the given type name (int: 0, boolean: false ...)
    /// </summary>
    /// <param name = "_name">Type name</param>
    /// <returns></returns>
	public System.Object GetDefaultValueForType(System.String _name)
    {
        if (_name == MXTXppTypes::BooleanTypeStr) return false;

        Types types = this.getXppTypeByTypeName(_name);
        
        switch (types)
        {
            case Types::Integer: return 0;
            case Types::Real: return 0.0;
            case Types::Container: return conNull();
            case Types::Date: return dateNull();
            case Types::Guid: return emptyGuid();
            case Types::UtcDateTime: return DateTimeUtil::minValue();
            case Types::Int64:
                {
                    int64 val = 0;
                    return val;
                }
            case Types::String: return "";
            case Types::Record: return DictTable::createRecord(_name);
            case Types::Enum: return SysDictEnum::newName(_name).firstValue();
        }

        return null;
	}

]]></Source>
			</Method>
			<Method>
				<Name>isEnumType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the given System.Type is an enumeration
    /// </summary>
    /// <param name = "_type">Systen.Type to check</param>
    /// <returns>True if it is an enum, otherwise false</returns>
    private boolean isEnumType(System.Type _type)
    {
        return SysDictEnum::newName(_type.Name) != null;
    }

]]></Source>
			</Method>
			<Method>
				<Name>ImplicitConversionExists</Name>
				<Source><![CDATA[
    public System.Boolean ImplicitConversionExists(System.Type _fromType, System.Type _toType)
    {
        if (_toType == null ) return false;
        if (_fromType == _toType) return true;
        if (_toType.IsAssignableFrom(_fromType) || _fromType.IsAssignableFrom(_toType)) return true;

        // anytype is always convertible
        if (_toType == MXTXppTypes::AnyTypeType) return true;

        // int, int64, real, boolean and enum are all implicitly convertible
        Set typeCheckSet = new Set(Types::Class);
        typeCheckSet.add(MXTXppTypes::Int32Type);
        typeCheckSet.add(MXTXppTypes::Int64Type);
        typeCheckSet.add(MXTXppTypes::DecimalType);
        typeCheckSet.add(MXTXppTypes::BooleanType);

        if ((typeCheckSet.in(_fromType) || this.isEnumType(_fromType)) &&
            (typeCheckSet.in(_toType) || this.isEnumType(_toType)))
        {
            return true;
        }

        return false;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>